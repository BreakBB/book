(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{50:function(e,n,i){e.exports=i.p+"assets/img/NetzwerkTopologien.e034f517.png"},61:function(e,n,i){"use strict";i.r(n);var t=[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"grundlagen"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#grundlagen","aria-hidden":"true"}},[e._v("#")]),e._v(" Grundlagen")]),t("h2",{attrs:{id:"kryptographie"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#kryptographie","aria-hidden":"true"}},[e._v("#")]),e._v(" Kryptographie")]),t("p",[e._v("Autor: Patrick Vogt")]),t("p",[e._v("Hash Funktionen, Digitale Signaturen, Integrität, Kerckhoffs Prinzip, Authentizität, PKI, MAC, Verbindlichkeit, Verschlüsselung, Vertraulichkeit, Algorithmen")]),t("h3",{attrs:{id:"zero-knowledge-proofs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#zero-knowledge-proofs","aria-hidden":"true"}},[e._v("#")]),e._v(" Zero knowledge Proofs")]),t("p",[e._v("Autor: Lukas Stuckstette")]),t("h2",{attrs:{id:"distributed-ledger-vs-datenbanken"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#distributed-ledger-vs-datenbanken","aria-hidden":"true"}},[e._v("#")]),e._v(" Distributed Ledger vs. Datenbanken")]),t("p",[e._v("Autor: Tim Jastrzembski")]),t("p",[e._v("Abgrenzung zu Datenbanken")]),t("h2",{attrs:{id:"verteilte-systeme"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#verteilte-systeme","aria-hidden":"true"}},[e._v("#")]),e._v(" Verteilte Systeme")]),t("p",[e._v("In diesem Kapitel soll definiert werden, was ein verteiltes System im bezug auf die Blockchain ist und welche Probleme\ngelöst werden müssen, damit vertrauen zwischen den einzelnen Nodes aufgebaut werden kann. Zudem sollen die gebräuchlichsten\nKonsens-Algorithmen erläutert werden, welche zur Zeit von den größten Blockchain-Netzwerken benutzt werden.")]),t("h3",{attrs:{id:"was-ist-ein-verteiltes-system"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#was-ist-ein-verteiltes-system","aria-hidden":"true"}},[e._v("#")]),e._v(" Was ist ein verteiltes System")]),t("p",[e._v("Ein verteiltes System ist prinzipiell eine Ansammlung von Computern, welche untereinander Nachrichten austauschen\nkönnen. Das Medium, über den dieser austausch stattfindet, ist dabei unbedeutend. Heutzutage wird für den Nachrichtenaustausch\nin den allermeisten Fällen das Internet genutzt, da hier Rechner von überall auf der Welt miteinander kommunizieren können und\ndie geschaffene Infrastruktur einfach zugänglich ist. Zudem wird ein verteiltes System darüber definiert, dass ein Benutzer das\nSystems als ein einziges Systems sieht, egal mit welchem Node beziehungsweise Computer im Systems er sich verbindet.")]),t("p",[e._v("Verteilte Systeme können verschiedene Typologien haben. Eine Topologie beschreibt in welcher weise die Nodes im System miteinander verbunden\nsind.\n"),t("img",{attrs:{src:i(50),alt:"Verschiedene Typologien"}})]),t("p",[e._v("Beispielsweise kennt eine Node in einem vollvermaschten System jede andere Node und kann so auf direktem Wege miteinander kommunizieren.\nDie direkte Kommunikation ist einer der Vorteile dieser Topologie. Wenn jedoch eine neue Node dem Netzwerk betreten will, muss nicht nur\ndie neue Node all bereits im Netzwerk bestehenden Nodes kennenlernen, auch müssen die bereits bestehenden Nodes über den betritt informiert\nwerden. Je nach größe des Netzwerkes und wie oft eine neue Node dem Netzwerk betritt kann dies zu einem Problem werden, wo das System nur noch\ndamit beschäftigt ist die Liste der Nodes aktuell zu halten.")]),t("p",[e._v("Bei den meisten Blockchain-Protokollen wird auf eine Abwandlung der vollvermaschten Topologie zurückgegriffen. Es kommt ein vermaschtes Netzwerk\noder auch Peer-to-Peer (P2P) Netzwerk zum Einsatz. Dabei können neue Nodes wie bei einem vollvermaschten Netz von jeder anderen Node\nhinzugefügt werden, allerdings können nicht alle Nodes eines Netzwerkes miteinander kommunizieren. Stattdesstehen steht jede Node mit\neiner handvoll anderer Nodes in Kontakt. Soll eine Nachricht zu einer Node gesendet werden welche nicht im direkten Kontakt mit der Absendernode\nsteht, so wird diese Nachricht vom Netzwerk selbst weitergeleitet, bis die Nachricht eine Node erreicht, welche in Kontakt mit der Empfängernode\nsteht.")]),t("h3",{attrs:{id:"die-blockchain"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#die-blockchain","aria-hidden":"true"}},[e._v("#")]),e._v(" Die Blockchain")]),t("p",[e._v("Die Blockchain ist ein verteiltes Kontobuch (Ledger), in welchem jede Transaktion von jedem Nutzer verzeichnet ist. Eine bestimmte Anzahl an\nTransaktionen werden zu Blöcken zusammengefasst. Diese Blöcke werden miteinander verkettet. Dies bedeutet, dass der Hash eines Nachfolgerblock\nim Header des Vorgängerblock gespeichert wird. Daher der Name Blockkette oder im englischen Blockchain. Über die Blockchain kann so die Reihenfolge\nder Transaktionen gespeichert werden. In einem verteilten Blockchain System hält jede Node eine Kopie der Blockchain. Zudem kann jede Node\nTransaktionen eines Nutzers entgegen nehmen und diese im Netzwerk bekannt machen. Das Problem, welches sich nun jeder Blockchain-Algorithmus lösen\nmuss ist, welche Node die gesammelten Transaktionen zu einem Block zusammenfassen und der Blockchain hinzufügen darf. Damit das Protokoll\nfunktioniert müssen alle Nodes im Netzwerk sich auf eine einzige Blockchain einigen. Hinzu kommt, dass Nodes dem Netzwerk frei betreten können,\nohne das eine zentrale Stelle die Node überprüft hat. So kann keiner Node im Netzwerk vertraut werden. Es muss also ein Weg gefunden werden der\nes dem Netzwerk erlaubt Blöcke von einer Node zur Kette hinzufügen zu lassen, obwohl die Absichten der hinzufügenden Node nicht bekannt sind.\nZudem muss geregelt werden was passiert wenn es zu Unstimmigkeiten in der Blockchain kommt, wenn beispielsweise zwei Blöcke zur selben Zeit gefunden\nwurden und es zu einer gabelung (fork) in der Blockchain kommt. Bei einem fork würden zwei verschiedenen Blöcke am Ende der Kette stehen. Dadurch\nkönnten Währungen doppelt ausgegeben werden, falls in den beiden letztens Blöcken Transaktionen von einem Konto zu zwei verschiedenen Empfängern\nverzeichnet sind. Die Aufgabe eines Konsens-Algorithmus ist es deshalb zu einer eindeutigen, gabelungsfreien Blockchain zu gelangen, auf welche\nsich alle Nodes im Netzwerk einigen können.")]),t("h3",{attrs:{id:"konsens-algorithmen"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#konsens-algorithmen","aria-hidden":"true"}},[e._v("#")]),e._v(" Konsens-Algorithmen")]),t("p",[e._v("Es gibt verschiedene Wege zu einem Konsens in einem verteilten System zu kommen. Viele Cryptowährungen unterscheiden sich alleine in ihrem\nKonsens-Algorithmus und versuchen so ein alleinstellungsmerkmal zu erlangen. Die gebräuchlichsten Konsens-Algorithmen sind:")]),t("ul",[t("li",[e._v("Proof-of-Work")]),t("li",[e._v("Proof-of-Stake")]),t("li",[e._v("Practical Byzantine Fault Tolerance")]),t("li",[e._v("Proof of Elapsed Time")]),t("li",[e._v("Federated Byzantine Agreement")])]),t("p",[e._v("Diese Algorithmen werden unteranderem von jeweils Bitcoin, Etherium, Ripple, InterLedger (Hyperledger) und Hyperledger Fabric verwendet.")]),t("h4",{attrs:{id:"proof-of-work"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#proof-of-work","aria-hidden":"true"}},[e._v("#")]),e._v(" Proof-of-Work")]),t("p",[e._v("Wie bei allen Blockchain-Protokollen wird auch beim Proof-of-Work Transaktionen zu Blöcken zusammengefasst. Jede Node die eine Transaktion empfängt\nspeichert diese zunächst in einem Cache und leitet sie an alle anderen Nodes im Netzwerk weiter. Liegen genug Transaktionen in einem Cache können\ndiese zu einem Block zusammengefasst werden. Alle Nodes fassen Transaktionen in einem eigenen Block zusammen. Dies hat zur Folge das nicht alle Nodes\ndie gleichen Transaktionen in ihrem Block aufgenommen haben, da Transaktionen beim verschiecken zwischen Nodes verloren gegangen sein können oder es\ndurch eine Verzögerung nicht in den aktuellen Block geschafft haben.")]),t("p",[e._v("Nachdem eine Node einen Block zusammengefasst hat, versucht sie einen Nonce zu finden, welcher, gehasht mit dem Blockhash, einen neuen Hashwert\nbildet. Dieser neu gebildete Hashwert muss allerdings eine bestimmte Anzahl an führenden Nullen besitzen um vom Netzwerk als der rechtmäßige\nNachfolgerblock anerkannt zu werden. Die Anzahl der führenden Nullen des Hashes wird Schwierigkeit (Difficulty) genannt. Diese Schwierigkeit passt\nsich dynamisch an das Netzwerkes an, sodass mit sich ändernder Rechenleistung der zeitliche Abstand der Blockerstellung gleichbleibend ist.\nDer eigentliche zeitliche Abstand ist je nach Implementierung des Proof-of-Work unterschiedlich. Im Falle von Bitcoin beträgt er 10 Minuten.")]),t("p",[e._v("Der neu gefundene Block wird von der findenden Node direkt in die Kopie ihrer Blockchain eingefügt und anschließend an alle weiteren Nodes gesendet.\nNodes die den neuen Block empfangen prüfen ihn auf seine Richtigkeit und fügen ihn dan zu ihrer eigenen Kopie der Blockchain hinzu. Sollte es in der\neigenen Blockchain bereits einen Nachfolgerblock geben, weil zwei Nodes zur selben Zeit einen Block gefunden haben, werden zunächst beide Blöcke als Nachfolger\nbehandelt. Nodes können frei entscheiden welchen der beiden Nachfolgerblöcke sie als legitim ansehen. Wird allerdings ein neuer Block gefunden welcher die\nBlockchain um einen Block verlängert, so wird nur der längste Teil der Blockchain als legitim angesehen und der andere Teil der Blockchain wird verlassen.\nEs kann vorkommen das eine Gabelung in der Kette zwei bis drei Blöcke erreicht, bevor ein Ast sich als legitim herrausstellt. Transaktionen die nur\nauf dem abgeschnittenen Ast verzeichnet waren werden somit ungültig. Aufgrund dessen sollte bei einer Transaktion gewartet werden bis mindestens Sechs\nBlöcke nach der eigentlichen Transaktion angehängt worden sind.")]),t("p",[e._v("Aufgrund der Tatsache das die Findung eines Blockes Rechenleistung benötigt kann davon ausgegangen werden das keine einzelne Person Blocks zur\nKette hinzufügen kann. Da nur die längste Kette von allen Nodes als legitim angesehen wird, müsste eine Person alleine jeden einzelnen neuen Block\nfinden, damit seine eigene Blockchain schneller wächst als die Blockchain an der das Rest der Netzwerkes arbeitet. Durch diesem Umstand wird die\ndezentralisierung gewährleistet. Sollte alllerdings eine Person oder Organization mehr als 51% der Rechenleistung kontrollieren, könnte diese\nOrganisation den Verlauf der Blockchain manipulieren.")]),t("h2",{attrs:{id:"dezentrale-anwendungen"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dezentrale-anwendungen","aria-hidden":"true"}},[e._v("#")]),e._v(" Dezentrale Anwendungen")]),t("ul",[t("li",[e._v("DApps, Web 3.0")])]),t("p",[e._v("Autor: Patrick Starzynski")])])}],r=i(0),s=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},t,!1,null,null,null);n.default=s.exports}}]);